package main

//有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

//          重量      价值
//物品0      1         15
//物品1      3         20
//物品2      4         30
// 背包最大重量为 4

//一维解法：
// 压缩二维状态：  dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
// 滚动数组
// 1. 确定dp数组的含义
//   dp[j], 容量为j的背包所能背的最大价值为 dp[j]
// 2. 递推公式
//   不放物品， dp[j]
//   放物品，   dp[j-weight[i]] + value[i]
//   递推公式， dp[j] = max(dp[j],dp[j-weight[i]] + value[i])
//3. 初始化
//   dp[0] = 0   其他的dp[j]也需要初始化0， 这样在递推的时候才不会被覆盖
//
//4. 遍历顺序
//  for (i=0;i<物品数量;i++)  物品
//     for(j=bigweight;j>weight[i];j--)   背包重量
//          dp[j] = max(dp[j],dp[j-weight[i]] + value[i])
//  遍历顺序：
//  先放物品0， 挨个放到背包重量中，判断j和value[i]的大小关系， 算的dp[1,2,3,4]
//如果正序，这里都是物品0情况下， dp[2] 会通过 dp[2-weitht[0]] + value[0] = dp[1] + value[0]获取值,这时候会重复计算
// 第二次遍历是在物品0取值的基础上，看 物品1 取不取
//  然后物品1， 需要把物品0,和物品1 任取放到背包容量中， 算的不放物品1，和放物品1两个情况比大小，
//  不放物品1的时候，和第一次遍历的dp结果一致， 放物品1的时候， 结算最大的重量，所以先减去当前物品1的重量后的背包价值+value[i]
//  如果正序遍历背包，这里dp[1],dp[2]会重复计算

//for(int i = 0; i < weight.size(); i++) { // 遍历物品
//    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
//        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
//
//    }
//}

// 切记要点、
// 1. 根据取与不取某个物品获取递推公式
// 2. 递推公式中是两个变量
func test_1_wei_bag_problem(weight, value []int, bagWeight int) int {
	// 定义 and 初始化
	dp := make([]int, bagWeight+1)
	// 递推顺序
	for i := 0; i < len(weight); i++ {
		// 这里必须倒序,区别二维,因为二维dp保存了i的状态
		for j := bagWeight; j >= weight[i]; j-- {
			// 递推公式
			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
		}
	}
	//fmt.Println(dp)
	return dp[bagWeight]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

//背包问题的类别主要有两种：0-1背包问题和完全背包问题。它们的主要区别在于每种物品可以取用的次数。
//
//0-1背包问题：每种物品只有一件，可以选择取或不取。问题是如何选择物品，使得背包中物品的总价值最大，并且总重量不超过背包的负载能力。
//在实现上，通常采用倒序遍历的方式 (for v := V to w[i])，保证每个物品只被考虑一次。
//
//完全背包问题：每种物品有无限件可用，也就是可以取用多次。问题也是如何选择物品，使得背包中物品总价值最大，且总重量不超过背包的负载能力。
//在实现上，常常采用正序遍历 (for v := w[i] to V)，保证每个物品可以被重复考虑。
//
//
//可先不考虑：
//如果求组合数就是外层for循环遍历物品，内层for遍历背包。
//如果求排列数就是外层for遍历背包，内层for循环遍历物品。
//

//相关题目如下：
//
//求组合数：动态规划：518.零钱兑换II(opens new window)
//求排列数：动态规划：377. 组合总和 Ⅳ (opens new window)、动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)
//如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：
//
//求最小数：动态规划：322. 零钱兑换 (opens new window)、动态规划：279.完全平方数(opens new window)
//对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了。
//
//#总结
